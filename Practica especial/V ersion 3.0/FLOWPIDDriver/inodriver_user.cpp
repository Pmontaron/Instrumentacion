//// ****** THIS FILE IS AUTOGENERATED ******
////
////          >>>> PLEASE ADAPT IT TO YOUR NEEDS <<<<
////
/// 
///  Filename; D:\Documentos\Licenciatura en Física\Laboratorios\Instrumentacion\Instrumentacion\Practica especial\V ersion 3.0\PIDDRIVER.py
///  Source class: FLOWPIDDriver
///  Generation timestamp: 2019-07-26T13:49:27.879974
///  Class code hash: b4513fff6bb16d2ee86ec4e6995533d4e153bd09
///
/////////////////////////////////////////////////////////////



//// ****** THIS FILE IS AUTOGENERATED ******
////
////          >>>> PLEASE ADAPT IT TO YOUR NEEDS <<<<
////
/// 
///  Filename; D:\Documentos\Licenciatura en Física\Laboratorios\Instrumentacion\Instrumentacion\Practica especial\V ersion 3.0\PIDDRIVER.py
///  Source class: FLOWPIDDriver
///  Generation timestamp: 2019-07-25T19:30:32.532207
///  Class code hash: b4513fff6bb16d2ee86ec4e6995533d4e153bd09
///
/////////////////////////////////////////////////////////////


#include "inodriver_user.h"
#include <AFMotor.h>
#include <Arduino.h>

//PID constants
double kp = 0;
double ki = 0;
double kd = 0;

//PWM values
float PWM_Value1;
float PWM_Value2;


//Bomba 1
int ENA = 10;
int IN1 = 9;
int IN2 = 8;
float pump_flow1=0;
float newvalue1;

//Bomba 2
int  ENB = 5;
int IN3 = 7;
int IN4 = 6;
float pump_flow2=0;
float newvalue2;

// Variable que determina si activo el loop de control o no
bool CtrlLoop = 0;

// Instancio variables que se usan durante el PID
unsigned long currentTime, previousTime;
double elapsedTime;
double error;
double lastError;
double input, output;
float setPoint;
double cumError, rateError;


// Instancio variables necesarias para medir flujo de manera continua
volatile int flow_frequency; // Measures flow sensor pulses
float l_hour; // Calculated litres/hour
float tolerance;
const unsigned char flowsensor_pin = 2; // Sensor Input
unsigned long cloopTime;
void flow () // Interrupt function
{
   flow_frequency++;
}

void user_setup() {

     setPoint = 0;                          //set point
     pinMode(flowsensor_pin, INPUT);
     digitalWrite(flowsensor_pin, HIGH); // Optional Internal Pull-Up
     attachInterrupt(0, flow, RISING); // Setup Interrupt
     sei(); // Enable interrupts
     currentTime = millis();
     cloopTime = currentTime;
     tolerance = 10*setPoint/100;
     //Declaramos los pines de las bombas como salida
     pinMode (ENA, OUTPUT);
     pinMode (IN1, OUTPUT);
     pinMode (IN2, OUTPUT);
     pinMode (ENB, OUTPUT);
     pinMode (IN3, OUTPUT);
     pinMode (IN4, OUTPUT);
     
}


// Funcion que utiliza el PID

double computePID(double inp){     
        currentTime = millis();                //get current time
        elapsedTime = (double)(currentTime - previousTime);        //compute time elapsed from previous computation
        
        error = setPoint - inp;                                // determine error
        cumError += error * elapsedTime;                // compute integral
        rateError = (error - lastError)/elapsedTime;   // compute derivative
 
        double out = kp*error + ki*cumError + kd*rateError;                //PID output               
 
        lastError = error;                                //remember current error
        previousTime = currentTime;                        //remember current time
 
        return out;                                        //have function return the PID output
}



// Aca empieza el loop, si la variable CtrlLoop es True (1) entra en el loop de control, y si vale False(0)no hace nada

void user_loop() {

 // Esta primera parte del loop va a estar corriendo siempre
     currentTime = millis();

 //MOVER MOTOR A
      digitalWrite(IN1, HIGH);
      digitalWrite(IN2, LOW);
      //Variando el próximo valor entre 0 y 255 varía la velocidad
      PWM_Value1=(pump_flow1 + 4.60)/0.42; //esto es solo para poder cambiar de flujop a unidad de la bomba
      analogWrite(ENA, PWM_Value1);


  //MOVER MOTOR B
      digitalWrite(IN3, HIGH);
      digitalWrite(IN4, LOW);
      //Variando el próximo valor entre 0 y 255 varía la velocidad
      PWM_Value2=(pump_flow2 + 3.60)/0.3; //esto es solo para poder cambiar de flujop a unidad de la bomba
      analogWrite(ENB, PWM_Value2);

//    Serial.println(l_hour, 3);
    

   // Every second, calculate and print litres/hour
   if(currentTime >= (cloopTime + 1000))
   {
      cloopTime = currentTime; // Updates cloopTime
      // Pulse frequency (Hz) = 7.5Q, Q is flow rate in L/min.
     // l_hour = ((flow_frequency * 60 / (7.5))* (160/1353.8))*(153/247); // (Pulse frequency x 60 min) / 7.5Q = flowrate in L/hour
      
      l_hour = (0.86941 * ((flow_frequency*60/7.5) *1.7886178862/30.24556546990604)) + 65.740;
      
      flow_frequency = 0; // Reset Counter

      if ((CtrlLoop == 1)) { //{||(setPoint - l_hour > tolerance)){
        output = computePID(l_hour);
        if (output > 102.5) {
          output = 102.5;
        }
        pump_flow1=output;
        analogWrite(ENA, (pump_flow1 + 4.60)/0.42);
       
       //pump_flow2=output;
      }
      
   }
  
}


// COMMAND: PF1, FEAT: pumpflow1
float get_PF1() {
  return pump_flow1;
};

int set_PF1(float value) {
  pump_flow1 = value;
  return 0;
};


// COMMAND: PF2, FEAT: pumpflow2
float get_PF2() {
  return pump_flow2;
};

int set_PF2(float value) {
  pump_flow2 = value;
  return 0;
};


// COMMAND: KD, FEAT: kd
float get_KD() {
  return kd;
};

int set_KD(float value) {
  kd = value;
  return 0;
};


// COMMAND: FV, FEAT: flowvalue
float get_FV() {
  return l_hour;
};


// COMMAND: SP, FEAT: setpoint
float get_SP() {
  return setPoint;
};

int set_SP(float value) {
  setPoint= value;
  return 0;
};


// COMMAND: CLEN, FEAT: cl
int get_CLEN() {
  return CtrlLoop;
};

int set_CLEN(int value) {
  CtrlLoop = (bool)value;
  return 0;
};


// COMMAND: KP, FEAT: kp
float get_KP() {
  return kp;
};

int set_KP(float value) {
  kp = value;
  return 0;
};


// COMMAND: KI, FEAT: ki
float get_KI() {
  return ki;
};

int set_KI(float value) {
  ki = value;
  return 0;
};
